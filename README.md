## Encryption Pipeline (in detail)

1. The program accepts a file to encrypt and performs symmetric key encryption (AES) on the file in chunks. The output is a series of encrypted chunk-files and a json file containing all the information required to decrypt the file.

2. The content encryption key (CEK) is generated by the sender at random (32 bytes for AES-256). This means that the recipient does not know the key for decryption. To solve this problem, the sender provides an encrypted version of the CEK, encrypted using a key encryption key (KEK), agree upon by both parties using a Diffie Hellman Key Exchange.

### Encryption Flow in Detail

1. **Generate the Content Encryption Key (CEK):**
   - Create a pseudorandom 32-byte AES key. This key will be used to encrypt all file chunks.

2. **Read the input file in chunks:**
   - Divide the file into chunks of fixed size.
   - Buffer each chunk into memory for individual encryption.

3. **Encrypt each chunk:**
   - For each chunk:
     - Generate a random 12-byte IV (nonce) to ensure ciphertext uniqueness.
     - Encrypt the chunk using AES in GCM mode with the CEK and the IV.
     - Write the encrypted chunk to an output directory.

> Note: Initialization vectors are a security measure. Given a fixed piece of plaintext and fixed key, the AES algorithm will provide you with a fixed ciphertext. This has the potential of leaking information about underlying plaintext and violates fundamental principles of cryptography. Using a nonce, each time you encrypt the same piece of plaintext, you get a unique piece of ciphertext. This increases the randomness of the ciphertext, which is a major cryptographic goal. Also, we are using AES in GCM mode, which is an authenticated encryption mode. So we ship the nonce in the json file for authentication purposes (therefore nonce has to be both random and unique).

   - Add metadata for each chunk in a list:
     - Chunk filename
     - Base64-encoded IV
     - SHA-256 checksum of original (unencrypted) chunk
     - Original (plaintext) chunk size

4. **Generate KEK using ECDH:**
   - Generate a fresh ephemeral ECC key pair.
   - Perform ECDH with the recipientâ€™s public key to derive a shared secret.
   - Then, hash the shared secret using SHA-256 to derive the final KEK (Key Encryption Key). This KEK will be used to encrypt the CEK securely using symmetric encryption.

5. **Encrypt the CEK using the KEK:**
   - Generate a new random 12-byte IV for CEK encryption.
   - Use AES-256-GCM with the derived KEK and this new IV to encrypt the CEK.
   - Store the resulting encrypted CEK and CEK IV in the metadata.

> Note: The CEK is encrypted using AES-256 in GCM mode (AEAD). The key used is the SHA-256 hash of the shared secret obtained via ECDH. A 12-byte nonce is used for this encryption too, and must be stored since GCM requires it during decryption for both confidentiality and authentication.

6. **Assemble the metadata file:**
   - Store file-level metadata like original name, size, chunk size, total chunks.
   - Add encryption info: algorithm names and key derivation scheme.
   - Store the list of all chunk metadata.
   - Store key metadata including:
     - base64-encoded encrypted CEK
     - CEK IV (base64)
     - senderâ€™s ephemeral ECC public key (base64)
     - SHA-256 fingerprint of recipientâ€™s ECC public key

7. **Write everything to disk:**
   - Write encrypted chunks to `chunks/` subdirectory.
   - Write the `metadata.json` file to the output directory.

---

## ðŸš€ Modes of Operation

You must provide **one of** the mode flags:

* `-e` â†’ **Encrypt mode**
* `-d` â†’ **Decrypt mode**

---

## Encrypt a File

```bash
go run main.go -e \
  -in input.txt \
  -out encrypted_output \
  -pub recipientKeyPair/recipient_pubkey.txt
```
---

## Decrypt a File

```bash
go run main.go -d \
  -m encrypted_output/metadata.json \
  -p recipientKeyPair/recipient_privkey.bin \
  -c encrypted_output/chunks/
```
---

## ðŸ“„ Flag Reference

| Flag     | Mode    | Required | Description                                      |
| -------- | ------- | -------- | ------------------------------------------------ |
| `-e`     | Encrypt | yes      | Run in encryption mode                           |
| `-d`     | Decrypt | yes      | Run in decryption mode                           |
| `-in`    | Encrypt | yes      | Path to input file to encrypt                    |
| `-out`   | Encrypt | no       | Output directory (default: `output`)             |
| `-pub`   | Encrypt | yes      | Path to recipient's ECC public key (base64 text) |
| `-chunk` | Encrypt | no       | Chunk size in bytes (default: 1048576 or 1MB)    |
| `-m`     | Decrypt | yes      | Path to metadata.json                            |
| `-p`     | Decrypt | yes      | Path to recipient's ECC private key (.bin)       |
| `-c`     | Decrypt | yes      | Path to directory containing encrypted chunks    |

---
